# 图
> grah

<!-- TOC -->

- [图](#图)
  - [前置知识 - 什么是图](#前置知识---什么是图)
  - [默认图](#默认图)
    - [内置函数](#内置函数)
    - [广度优先](#广度优先)
      - [默认图 - 寻找最短路径](#默认图---寻找最短路径)
    - [深度优先](#深度优先)
      - [拓扑结构](#拓扑结构)

<!-- /TOC -->

## 前置知识 - 什么是图

![grah](https://raw.githubusercontent.com/JiangWeixian/JS-Books/master/JS%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9B%BE/img/grah.png)

长得很像是树

额外：

1. 连接线可以有方向
2. 可以有权重

**图结构需要存储什么数据**

1. 默认连接线是单向且没有权重的 - 需要保存节点和连接线(谁和谁连接了)

**图的方法**

1. 遍历 - 深度和广度
  * 广度(广度优先搜索算法会从指定的第一个顶点开始遍历图) - 和树结构不同地方在于，并没有左右子树概念。如果**Map(数据结构Map)**，从顶点开始，然后先访问**完毕**(也就是输出)连接点，然后再依次访问连接点的**连接点**。
  
    **图如何确定顶点？**

    个人认为应该是任意一个节点都可以是顶点。能确定顶点的都是有方向的图，没有方向(或者说是双向的)个人理解任意一点都可以。
    
  * 深度优先，从顶点开始`A`，先访问其连接点`B`(**并不会全部访问**完所有连接点)，而是继续访问连接点`E`(所以叫深度)，可以发现从`B`点开始的那个步骤很像就是`A`点步骤的重复。**深度比广度更适合递归。**

  

**两种方式存储数据**

1. 数组 - 如果图中6个节点就是6*6的数组，如果有连接数值对应位置设置为1。如果没有就设置为0
2. Map(数据结构Map) - `key`是节点，`value`是和`key`相连的节点

## 默认图 

* 连接单向以及**权重为1**

* 含有两个内置属性，分别是`vertex`以及`adlist`，分别存储节点和边。

  ```JavaScript
  vertices = []
  adjList = new Dictionary()
  ```

### 内置函数

* addVertex - 添加节点
* addEdge - 在已经有的节点基础上，添加和那些边相互连接
* 广度优先
* 深度优先

### 广度优先

* 定义一个状态机，分别是节点未访问(默认状态)，访问(和它相互连接的节点还没有**完全访问完毕**)，探索完毕(节点被访问以及下面的节点也完全被访问完毕)
  * white - 未访问
  * grey - 访问
  * black - 探索完毕
* 定义一个队列(**广度优先特有的，在树结构的广度中也是如此**)，记录**访问状态**的节点，如果是**探索完毕**就不要添加了。

**开始广度优先**

添加起始节点到队列

1. **弹出**队列第一个节点，从给定节点开始访问
2. 访问下面连接节点，如果下面连接节点在对应状态机里面是`gray(访问)状态`，就**添加**到队列中
3. 节点探索完毕，回到第一步
4. 直到队列为空

#### 默认图 - 寻找最短路径

实现**某一个定点到任意定点**的最短路径。

由于权重为1(也就是连接线没有长短之分)，所以直接最短路径和连接线数目有关。

* 记录路径长度 - `d`
* 记录该点的上一点(如果该点第一次被访问呢) - `p`

**开始寻找最短路径(广度优先算法流程)**

1. **弹出**队列第一个节点，从给定节点开始访问
2. 访问下面连接节点，如果下面连接节点在对应状态机里面是`gray(访问)状态`，就**添加**到队列中。设置`p`中该点上一个节点(保证下一次访问同一个节点不会加入`p`)；设置`d`中该点路径为**上一个节点路径+1**(因为达到该点需要经过上一个节点，所以该点路径是上一个点路径+1)
  > 如果下面连接节点在对应状态机里面是`gray(访问)状态`才会被加入`d&p`。保证某点上一个点只有唯一一种可能；**因为对最短路径寻找来说，第一次访问最短，第二次访问一定是经过了中间节点。**
3. 节点探索完毕，回到第一步
4. 直到队列为空

**还需要经过第二步骤**

假设我们得到的`p`是`predecessors: [A: null, B: "A", C: "A", D: "A", E: "B", F: "B", G: "C", H: "D", I: "E"] `

大致解释一下：

* A是起点，所以上一个节点是`null`
* 假设`E`是终点，`E`上一个点`B`，`B`上一个点`A`。所以**A到E**就是**A->B->E**

**根据`p`绘制出路径图**

以A为起点，寻找终点`X`。

1. 如果`X`上一个节点是`A`那么终止
2. 如果不是，找到`X`的上一个节点，直到上一个节点是`A`

### 深度优先

适合递归实现。

1. 从某一点`v`开始(**未被探索的**) - 访问未被探索是关键所在
2. 访问某一点的连接点`w`
  * 然后访问连接点的连接点`x`(第一个) - 对于`x`是从第1步开始重复，直到最后一层。然后回到上一步，从第2个节点继续重复。
3. 当某一个节点的子链接点都访问完全之后，才会标记为**被探索**

**看图更为明确一些：**

![dfs](https://raw.githubusercontent.com/JiangWeixian/JS-Books/master/JS%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9B%BE/img/dfs.png)

#### 拓扑结构

**拓扑结构如图所示：**

![拓扑结构](https://raw.githubusercontent.com/JiangWeixian/JS-Books/master/JS%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9B%BE/img/%E6%8B%93%E6%89%91%E7%BB%93%E6%9E%84.png)

* **被访问**会被标记为上先后顺序的数字，左边
* **探索完毕**之后标记上探索完毕的记号，代表先后顺序，右边

可以代表任务先后顺序

被访问先后顺序很好理解，探索完毕先后顺序是由于这是**所有子节点都被访问完毕的状态**。所以最外层的节点是最后被退出的。