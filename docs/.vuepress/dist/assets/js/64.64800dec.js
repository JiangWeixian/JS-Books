(window.webpackJsonp=window.webpackJsonp||[]).push([[64],{228:function(t,e,r){"use strict";r.r(e);var _=r(0),i=Object(_.a)({},function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("div",{staticClass:"content"},[t._m(0),t._v(" "),t._m(1),t._v(" "),t._m(2),t._v(" "),t._m(3),t._v(" "),r("p",[t._v("具体解释可见:")]),t._v(" "),r("ol",[t._m(4),t._v(" "),r("li",[r("a",{attrs:{href:"https://zh.wikipedia.org/zh-hans/%E5%A4%A7O%E7%AC%A6%E5%8F%B7",target:"_blank",rel:"noopener noreferrer"}},[t._v("维基百科-大O表示法"),r("OutboundLink")],1)])]),t._v(" "),r("p",[t._v("大致解释一下：")]),t._v(" "),t._m(5),t._v(" "),r("p",[t._v("计算流程可以分为非递归算法和递归算法：")]),t._v(" "),t._m(6),t._v(" "),t._m(7),t._v(" "),t._m(8),t._v(" "),t._m(9),t._v(" "),t._m(10),t._v(" "),r("p",[t._v("具体可见"),r("a",{attrs:{href:"https://zh.wikipedia.org/wiki/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F",target:"_blank",rel:"noopener noreferrer"}},[t._v("维基百科-插入排序"),r("OutboundLink")],1)]),t._v(" "),t._m(11),t._v(" "),t._m(12),t._v(" "),r("p",[t._v("流程可见下面"),r("a",{attrs:{href:"https://zh.wikipedia.org/wiki/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F#/media/File:Insertion-sort-example-300px.gif",target:"_blank",rel:"noopener noreferrer"}},[t._v("GIF"),r("OutboundLink")],1)]),t._v(" "),t._m(13),t._v(" "),t._m(14),t._v(" "),t._m(15),t._v(" "),r("p",[t._v("元素原始是从大到小，期望从小到大排序。")]),t._v(" "),t._m(16),t._v(" "),r("p",[t._v("具体可见"),r("a",{attrs:{href:"https://zh.wikipedia.org/wiki/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F",target:"_blank",rel:"noopener noreferrer"}},[t._v("维基百科-冒泡排序"),r("OutboundLink")],1)]),t._v(" "),r("p",[t._v("算法复杂度和插入排序类似。有两种情况：")]),t._v(" "),t._m(17),t._v(" "),t._m(18),t._v(" "),t._m(19),t._v(" "),t._m(20),t._v(" "),t._m(21),t._v(" "),t._m(22),t._v(" "),r("p",[t._v("详见"),r("a",{attrs:{href:"https://zh.wikipedia.org/wiki/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F",target:"_blank",rel:"noopener noreferrer"}},[t._v("维基百科-归并排序"),r("OutboundLink")],1)]),t._v(" "),t._m(23),t._v(" "),t._m(24),t._v(" "),t._m(25),t._v(" "),t._m(26),t._v(" "),t._m(27),t._v(" "),r("p",[t._v("以下是分解步骤：")]),t._v(" "),t._m(28),t._v(" "),t._m(29),t._v(" "),t._m(30),t._v(" "),t._m(31),t._v(" "),r("p",[t._v("因为对于合并步骤来说，需要进一步比较两个序列大小。属于一个个比较，然后较小的优先添加到新的数组里面。可能其中一个序列被优先添加完，所以要考虑这种情况下。将另一个序列的所有元素合并到新的数组中。")]),t._v(" "),t._m(32),t._v(" "),t._m(33),t._v(" "),t._m(34),t._v(" "),r("p",[t._v("算法复杂度只有"),r("code",[t._v("nlogn")]),r("a",{attrs:{href:"https://zh.wikipedia.org/wiki/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F",target:"_blank",rel:"noopener noreferrer"}},[t._v("维基百科-快速排序"),r("OutboundLink")],1),t._v("。")]),t._v(" "),r("p",[t._v("算法流程为：")]),t._v(" "),t._m(35),t._v(" "),t._m(36),t._v(" "),t._m(37),t._v(" "),t._m(38),t._v(" "),t._m(39),t._v(" "),t._m(40),t._v(" "),t._m(41),t._v(" "),r("ul",[r("li",[r("a",{attrs:{href:"https://github.com/JiangWeixian/JS-Books/blob/master/JS%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E9%83%A8%E5%88%86/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/insertSort.js",target:"_blank",rel:"noopener noreferrer"}},[t._v("插入排序 - insertSort.js"),r("OutboundLink")],1)]),t._v(" "),r("li",[r("a",{attrs:{href:"https://github.com/JiangWeixian/JS-Books/blob/master/JS%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E9%83%A8%E5%88%86/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/bubbleSorted.js",target:"_blank",rel:"noopener noreferrer"}},[t._v("冒泡排序 - bubbleSort.js"),r("OutboundLink")],1)]),t._v(" "),r("li",[r("a",{attrs:{href:"https://github.com/JiangWeixian/JS-Books/blob/master/JS%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E9%83%A8%E5%88%86/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/mergeSort.js",target:"_blank",rel:"noopener noreferrer"}},[t._v("归并排序 - mergeSort.js"),r("OutboundLink")],1)]),t._v(" "),r("li",[r("a",{attrs:{href:"https://github.com/JiangWeixian/JS-Books/blob/master/JS%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E9%83%A8%E5%88%86/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/quickSort.js",target:"_blank",rel:"noopener noreferrer"}},[t._v("快速排序"),r("OutboundLink")],1)])])])},[function(){var t=this.$createElement,e=this._self._c||t;return e("h1",{attrs:{id:"%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95","aria-hidden":"true"}},[this._v("#")]),this._v(" 排序算法")])},function(){var t=this.$createElement,e=this._self._c||t;return e("blockquote",[e("p",[this._v("各种排序算法以及如何计算复杂度初探")])])},function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("ul",[r("li",[r("a",{attrs:{href:"#%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"}},[t._v("排序算法")]),t._v(" "),r("ul",[r("li",[r("a",{attrs:{href:"#%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86---%E8%AE%A1%E7%AE%97%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6"}},[t._v("前置知识 - 计算算法复杂度")])]),t._v(" "),r("li",[r("a",{attrs:{href:"#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"}},[t._v("插入排序")]),t._v(" "),r("ul",[r("li",[r("a",{attrs:{href:"#%E5%AE%9E%E7%8E%B0%E6%B5%81%E7%A8%8B"}},[t._v("实现流程")])])])]),t._v(" "),r("li",[r("a",{attrs:{href:"#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"}},[t._v("冒泡排序")])]),t._v(" "),r("li",[r("a",{attrs:{href:"#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"}},[t._v("归并排序")]),t._v(" "),r("ul",[r("li",[r("a",{attrs:{href:"#%E5%AE%9E%E7%8E%B0%E5%AE%83"}},[t._v("实现它")])])])]),t._v(" "),r("li",[r("a",{attrs:{href:"#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"}},[t._v("快速排序")])]),t._v(" "),r("li",[r("a",{attrs:{href:"#%E5%AE%9E%E7%8E%B0"}},[t._v("实现")])])])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86---%E8%AE%A1%E7%AE%97%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86---%E8%AE%A1%E7%AE%97%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6","aria-hidden":"true"}},[this._v("#")]),this._v(" 前置知识 - 计算算法复杂度")])},function(){var t=this.$createElement,e=this._self._c||t;return e("li",[e("a",{attrs:{href:""}},[e("strong",[this._v("网易公开课-算法导论-第2课")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("算法复杂度就是"),e("img",{attrs:{src:"http://www.sciweavers.org/tex2img.php?eq=%20%5CTheta%20%28%20n%5E%7B2%7D%20%29&bc=White&fc=Black&im=jpg&fs=12&ff=arev&edit=0",alt:"img"}}),this._v(" 表示，括号内会变。只是一种近视表示，表示的是算法复杂度的"),e("strong",[this._v("上限")]),this._v("，意味着小于等于这个算法复杂度。就像是是"),e("img",{attrs:{src:"http://www.sciweavers.org/tex2img.php?eq=%20%5CTheta%20%28%20n%5E%7B2%7D%20%29&bc=White&fc=Black&im=jpg&fs=12&ff=arev&edit=0",alt:"img"}}),this._v(" 意味着小于等于"),e("code",[this._v("c*n^2")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("ul",[e("li",[this._v("非递归算法 - 以插入排序为例子。递归计算为"),e("code",[this._v("1+2+...n=(1+n)*n/2")]),this._v("，根据大O表示法只保留算法的最高次幂，所以该算法就是一个"),e("img",{attrs:{src:"http://www.sciweavers.org/tex2img.php?eq=%20%5CTheta%20%28%20n%5E%7B2%7D%20%29&bc=White&fc=Black&im=jpg&fs=12&ff=arev&edit=0",alt:"img"}}),this._v("复杂度的算法。")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("strong",[this._v("递归算法的复杂度计算过程等我看完那门课程之后补充。")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("strong",[this._v("算法复杂度之间关系：")])])},function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("ol",[r("li",[t._v("算法复杂度高也有高的好处，一般来说这个能够任意情况下适用。")]),t._v(" "),r("li",[t._v("从以上算法复杂度计算来看，可以看见算法复杂度和输入"),r("code",[t._v("n")]),t._v("有关，也就是"),r("strong",[t._v("数据规模")]),t._v("。有的时候算法复杂度比较低的算法在大规模数据的时候表现很好，但是在"),r("strong",[t._v("低规模的数据上表现就不一定有算法复杂度高的优秀。")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F","aria-hidden":"true"}},[this._v("#")]),this._v(" 插入排序")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("计算复杂度："),e("img",{attrs:{src:"http://www.sciweavers.org/tex2img.php?eq=%20%5CTheta%20%28%20n%5E%7B2%7D%20%29&bc=White&fc=Black&im=jpg&fs=12&ff=arev&edit=0",alt:"img"}})])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"%E5%AE%9E%E7%8E%B0%E6%B5%81%E7%A8%8B"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#%E5%AE%9E%E7%8E%B0%E6%B5%81%E7%A8%8B","aria-hidden":"true"}},[this._v("#")]),this._v(" 实现流程")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("strong",[this._v("引用至维基百科(从小到大排序)：")])])},function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("ol",[r("li",[t._v("从第一个元素开始，该元素可以认为已经被排序")]),t._v(" "),r("li",[t._v("取出"),r("strong",[t._v("下一个元素")]),t._v("，在已经排序的元素序列中"),r("strong",[t._v("从后向前")]),t._v("扫描 - 已经排序序列意思为下一个元素之前的元素")]),t._v(" "),r("li",[t._v("如果该元素(已排序，指的是第2步骤中下一个元素的之前元素与)大于新元素(指的是第2步骤上面下一个元素)，将该元素移到下一位置")]),t._v(" "),r("li",[t._v("重复步骤3，直到找到已排序的元素小于或者等于新元素的位置")]),t._v(" "),r("li",[t._v("将新元素插入到该位置后(此时该位置上元素比新元素小)")]),t._v(" "),r("li",[t._v("重复步骤2~5")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("strong",[this._v("最差情况：")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F","aria-hidden":"true"}},[this._v("#")]),this._v(" 冒泡排序")])},function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("ol",[r("li",[t._v("如果循环都是从头到尾的循环，那么就是"),r("code",[t._v("n*n")])]),t._v(" "),r("li",[t._v("如果是优化过后(排除末尾的元素)的就是"),r("code",[t._v("(1+n)*n/2")]),t._v(" - "),r("a",{attrs:{href:""}},[t._v("bubbleSort.js")]),t._v("实现的是优化过后的。")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("strong",[this._v("引维基百科算法流程：")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("ol",[e("li",[this._v("比较相邻的元素。如果第一个比第二个大，就交换他们两个。")]),this._v(" "),e("li",[this._v("对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("第1步和第2步，可以视为是一个"),e("strong",[this._v("循环流程")]),this._v("，注意在一个循环过后，"),e("strong",[this._v("最后一个元素将会是最大的那个元素")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("ol",{attrs:{start:"3"}},[e("li",[this._v("针对所有的元素重复"),e("strong",[this._v("以上的步骤")]),this._v("，除了最后一个。")]),this._v(" "),e("li",[this._v("持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F","aria-hidden":"true"}},[this._v("#")]),this._v(" 归并排序")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("归并排序思想在于将排序这个任分解为一个个小目标，每个小目标再一次分解，知道小目标只有一个。所以这个排序方法是"),e("strong",[this._v("非常适合递归")]),this._v("的排序方法。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"%E5%AE%9E%E7%8E%B0%E5%AE%83"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#%E5%AE%9E%E7%8E%B0%E5%AE%83","aria-hidden":"true"}},[this._v("#")]),this._v(" 实现它")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("strong",[this._v("引用维基百科算法流程：")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("img",{attrs:{src:"https://raw.githubusercontent.com/JiangWeixian/JS-Books/master/JS%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E9%83%A8%E5%88%86/img/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F.jpeg",alt:"归并排序"}})])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("从上图可以看出来是分为两个步骤："),e("strong",[this._v("大小比较在发生合并步骤中。")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("按照图片中步骤"),e("strong",[this._v("分解")]),this._v("(递归方法)，一定能够分解为只有单个元素的数组。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("ol",[e("li",[this._v("递归边界 - 每个长度为1的数组")]),this._v(" "),e("li",[this._v("递归中 - 不断分解数组，分别为左边和右边。")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("以下是合并的步骤(也处在递归中)，定义一个"),e("strong",[this._v("合并函数")]),this._v("：")])},function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("ol",[r("li",[t._v("申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列")]),t._v(" "),r("li",[t._v("设定两个指针，最初位置分别为两个"),r("strong",[t._v("已经排序")]),t._v("序列的起始位置")]),t._v(" "),r("li",[t._v("比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置")]),t._v(" "),r("li",[t._v("重复步骤3直到"),r("strong",[t._v("某一指针")]),t._v("到达序列尾")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("ol",{attrs:{start:"5"}},[e("li",[this._v("将另一序列剩下的所有元素直接复制到合并序列尾")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("然后返回这个数组，然后被上一步"),e("strong",[this._v("合并函数操作")]),this._v("，也是整个"),e("strong",[this._v("合并排序函数的返回值")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F","aria-hidden":"true"}},[this._v("#")]),this._v(" 快速排序")])},function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("ol",[r("li",[t._v("在一个数组中选择中元素作为主元("),r("code",[t._v("privot")]),t._v("，一般选择中间元素，表现最好)")]),t._v(" "),r("li",[t._v("设置两个指针，分别为"),r("code",[t._v("left&right")]),t._v("，分别指向数组开头末尾w。"),r("code",[t._v("left")]),t._v("指针指 "),r("strong",[t._v("第一个比主元大的元素")]),t._v("，"),r("code",[t._v("right")]),t._v("指向第一个比主元小得元素(如果想要从小到大排序)。如果"),r("code",[t._v("left")]),t._v("指针位置比"),r("code",[t._v("right")]),t._v("小("),r("strong",[t._v("比较指针位置并不是元素大小")]),t._v(")就交换这两个元素。直到"),r("code",[t._v("left")]),t._v("指针大于了"),r("code",[t._v("right")]),t._v("指针。")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("blockquote",[e("p",[this._v("经过step2，数组发生了什么(left到了right后面)，此时 **能够保证的是以left为界的左右两边数据，右边的大于左边。**但是没有办法保证left左边的数组的大小顺序。所以接下来要以"),e("code",[this._v("left")]),this._v("为划分两个数组的边界。进行step3。")])])},function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("ol",{attrs:{start:"3"}},[r("li",[t._v("以此时的"),r("code",[t._v("left.new")]),t._v("指针为界，和之前的"),r("code",[t._v("left.old")]),t._v("以及"),r("code",[t._v("right.old")]),t._v("来划分两个数组。对两边数组执行上面两个步骤相同的操作。因此是适合"),r("strong",[t._v("递归的算法")]),t._v("。")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("strong",[this._v("问题在于？递归边界是什么？")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("首先我们直接操作数组元素，并不需要"),e("code",[this._v("return")]),this._v("至上一步操作。所以没有"),e("code",[this._v("return")]),this._v("。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("其次可以看到算法在不断划分数组，所以**边界应该是什么时候不需要划分数组。**但数组边界比不足以和之前的"),e("code",[this._v("left")]),this._v("或者"),e("code",[this._v("right")]),this._v("构成两个子数组。就停止这个快速排序的递归。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"%E5%AE%9E%E7%8E%B0"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#%E5%AE%9E%E7%8E%B0","aria-hidden":"true"}},[this._v("#")]),this._v(" 实现")])}],!1,null,null,null);e.default=i.exports}}]);