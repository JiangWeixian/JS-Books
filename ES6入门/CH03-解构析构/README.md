# 1. 解构析构

<!-- TOC -->

- [1. 解构析构](#1-解构析构)
  - [1.1. 前置知识 - 原则](#11-前置知识---原则)
  - [1.2. 解构 - []](#12-解构---)
    - [1.2.1. 特殊情况](#121-特殊情况)
  - [1.3. 解构 - {}](#13-解构---)
    - [1.3.1. 特殊应用](#131-特殊应用)
  - [1.4. 解构 - 字符串](#14-解构---字符串)
  - [1.5. 解构 - 函数参数](#15-解构---函数参数)
  - [应用](#应用)

<!-- /TOC -->

## 1.1. 前置知识 - 原则

解构析构发生在拥有`itertor`结构的对象上。不仅仅局限于`[] or {}`，**但是格式仅仅局限于`[] or {} = 被解构的对象`**。

对应用解构析构有几个原则：

* 等号两边，对应位置上格式要一致：[] = []
* 等号左右的变量数量不等于右边的数据数量
* 以及`[]`解构普通数据，而`{}`适用于一切对象，用于解构等号右边的 **属性**
* 支持默认数值，当等号右边数据为`undefined`或者少于右边数据数量的时候成立

## 1.2. 解构 - []

**不用于解构等号右边的属性！** 对应以上规则，以下情况成立：

```JavaScript
// 变量数目
let [x, y] = [1, 2]
let [x] = [1,2]

// 想要一一解析，格式要对
let [x, [y, z]] = [1, [2, 3]]
// 如果是以下情况，y=[2,3], z=undefined
let [x, y, z] = [1, [2, 3]]

// 默认值
let [x = 0, y = 0] = [1, 2]
let [x, y, z = 1] = [1, 2]
```

### 1.2.1. 特殊情况

```JavaScript
// 都无法得到期望的x = y= 2。x=y后面y被忽略了。
let [x = y, y] = [1, 2]
var [x = y, y] = [1, 2]
```

## 1.3. 解构 - {}

**这个是解构右边的属性的！！** 以上共有规则同样成立：

注意`x, y, z`指的是`{x: 1, y: 2}`上面的属性。

```JavaScript
// 格式要对
let {x, y} = {x: 1, y: 2}
// 嵌套。无法像[]那么书写
// y: 意为取得key=y的数据然后送给后面表达式解析
let {x, y, y: {z, v}} = {x: 1, y: {z: 2, v: 1}}
// 嵌套[] 和解构[]并没有冲突
let {x, y, y: [z, v]} = {x: 1, y: [1, 2]}
```

```JavaScript
// 数量不对应没关系
let {x, y, z} = {x: 1, y: 2}
```

**注意**

* 同样可以使用默认数值。
* 可以解构json

### 1.3.1. 特殊应用

如果`{}`解构的是属性，那么应该不仅仅局限于`{x: 1, y: [1, 2]}`的数据。任何含有属性数据的数据都可以，**这一点在导入模块已经体现了**

```JavaScript
// 数组上有length这个属性
let {length: x} = [1, 2]
// 获得function原型上面的call
let {call: raw_fn} = Function
```

## 1.4. 解构 - 字符串

既有数组特性以及对象特性，{} or []都可以！

## 1.5. 解构 - 函数参数

* [] or {} 都是支持 - []
* 要明白函数参数的解构析构做了怎样的操作 - 

    ```JavaScript
    function add([x, y]){
      return x + y;
    }
    add([1,2])
    ```

    其实在函数内部`[x, y] = [1, 2]`。对于`{}`一样。


明白了这一点，就可以知道设置函数默认参数为：

* `[x=1, y=1] = []` - 在传入`[1, 2]`之后，后面的`[]`就会被替换
* `[x, y] = [1, 2]` - 在传入`[1, 2]`之后，后面的`[1, 2]`就会被替换

依据上面的规则，如果传入`[]`或者`[1]`，两个的表现是不一样的。

## 应用

* 获取函数返回数值就不说了
* **交换数值**
    ```JavaScript
    let x = 1;
    let y = 2;

    [x, y] = [y, x];
    ```

    但是`let [x=y, y=x] = [1, 2]`
    



