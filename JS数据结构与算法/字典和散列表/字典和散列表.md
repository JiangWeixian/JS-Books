# 字典和散列表
> Dictionary&hashtable

<!-- TOC -->

- [字典和散列表](#字典和散列表)
  - [前置知识 - 字典和散列表](#前置知识---字典和散列表)
  - [字典](#字典)
    - [内置函数](#内置函数)
  - [哈希表 - 散列表](#哈希表---散列表)
  - [实现](#实现)

<!-- /TOC -->

## 前置知识 - 字典和散列表

**字典**

* 和[set]()很像 - 都需要通过键值对来设置键值对。**区别在于，字典添加元素的时候并不需要检查是否已经含有这个元素。直接覆盖原先`key`的`value`**

**散列表**

也就是**hash存储**，文中介绍了简单的两种`hash table`

* 并不是键值对，而是数组
* 将一个字符串转换为`hash`数值，然后将它作为数组里面下标(并没有出于保密的考虑)，所以这样构成的数据结构有很多`undefied`的数值。

## 字典

可能没有实现的必要，权当强迫症。

### 内置函数

* get
* set
* delete
* has
* clear
* size
* keys
* values

## 哈希表 - 散列表

[哈希表-维基百科](https://zh.wikipedia.org/wiki/%E5%93%88%E5%B8%8C%E8%A1%A8)

> 是根据键（Key）而直接访问在内存存储位置的数据结构

* 是查找效率较高的算法，因为可以通过`item[hasjkey]`来找到一个变量`value`
* 哈希表存在的问题是，可能出现相同的`hashkey`。哈希表不会覆盖(出现这样的情况，哈希表称之为冲突，冲突越多，效率越低)，为了避免这样的冲突可能会在相同`hashkey`位置上实现一个**链表**。这样解决冲突的方式是要带来效率下降的。因此一般**哈希表都是存不满数据的。**

**但是会存在一个疑惑的地方？为什么能够实现更高效率，也通过下标的字典难道不行吗？**

* [hashmap-dic-list效率实验](https://www.cnblogs.com/zery/p/3413407.html) / 但是并没有说明原因

可能的下标索引更快？

## 实现

* [dictionary.js]()

