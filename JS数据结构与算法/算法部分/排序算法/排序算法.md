# 排序算法
> 各种排序算法以及如何计算复杂度初探

<!-- TOC -->

- [排序算法](#排序算法)
  - [前置知识 - 计算算法复杂度](#前置知识---计算算法复杂度)
  - [插入排序](#插入排序)
    - [实现流程](#实现流程)
  - [实现](#实现)

<!-- /TOC -->

## 前置知识 - 计算算法复杂度

具体解释可见:

1. [**网易公开课-算法导论-第2课**]()
2. [维基百科-大O表示法](https://zh.wikipedia.org/zh-hans/%E5%A4%A7O%E7%AC%A6%E5%8F%B7)

大致解释一下：

算法复杂度就是![img](http://www.sciweavers.org/tex2img.php?eq=%20%5CTheta%20%28%20n%5E%7B2%7D%20%29&bc=White&fc=Black&im=jpg&fs=12&ff=arev&edit=0) 表示，括号内会变。只是一种近视表示，表示的是算法复杂度的**上限**，意味着小于等于这个算法复杂度。就像是是![img](http://www.sciweavers.org/tex2img.php?eq=%20%5CTheta%20%28%20n%5E%7B2%7D%20%29&bc=White&fc=Black&im=jpg&fs=12&ff=arev&edit=0) 意味着小于等于`c*n^2`

计算流程可以分为非递归算法和递归算法：

* 非递归算法 - 以插入排序为例子。递归计算为`1+2+...n=(1+n)*n/2`，根据大O表示法只保留算法的最高次幂，所以该算法就是一个![img](http://www.sciweavers.org/tex2img.php?eq=%20%5CTheta%20%28%20n%5E%7B2%7D%20%29&bc=White&fc=Black&im=jpg&fs=12&ff=arev&edit=0)复杂度的算法。

**递归算法的复杂度计算过程等我看完那门课程之后补充。**

## 插入排序

具体可见[维基百科-插入排序](https://zh.wikipedia.org/wiki/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F)

计算复杂度：![img](http://www.sciweavers.org/tex2img.php?eq=%20%5CTheta%20%28%20n%5E%7B2%7D%20%29&bc=White&fc=Black&im=jpg&fs=12&ff=arev&edit=0) 

### 实现流程

流程可见下面[GIF](https://zh.wikipedia.org/wiki/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F#/media/File:Insertion-sort-example-300px.gif)

**引用至维基百科(从小到大排序)：**

1. 从第一个元素开始，该元素可以认为已经被排序
2. 取出**下一个元素**，在已经排序的元素序列中**从后向前**扫描 - 已经排序序列意思为下一个元素之前的元素
3. 如果该元素(已排序，指的是第2步骤中下一个元素的之前元素与)大于新元素(指的是第2步骤上面下一个元素)，将该元素移到下一位置
4. 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置
5. 将新元素插入到该位置后(此时该位置上元素比新元素小)
6. 重复步骤2~5

**最差情况：**

元素原始是从大到小，期望从小到大排序。

## 实现

[插入排序 - insertSort.js]()
