# 动态规划&贪心算法

## 两则解析

* [维基百科-贪心算法](https://zh.wikipedia.org/zh-hans/%E8%B4%AA%E5%BF%83%E6%B3%95)
* [维基百科-动态规划](https://zh.wikipedia.org/zh-hans/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92)

**动态规划**

把一个问题最小化，然后求解这个 **最小化问题的最优解**。

如果你类别数学里面的求证(就是那个k=1成立，假设k=n-1成立，如果证明k=n成立的话，那么整个式子就成立的那种证明方式的话)。就会发现这两者有相同的地方。

所以可以得到动态规划的思路是：先得到`n=1`(这里的**1**是该问题的最小单元)的最优解，然后根据`n=1`得到`n=2`，依次类推。最终得到想要求解问题的最优解。

**贪心算法**

和 **动态规划**很容易混淆。

> 贪心法，又称贪心算法、贪婪算法、或称贪婪法，是一种在每一步选择中都采取在**当前状态下**最好或最优（即最有利）的选择，从而希望**导致结果是最好或最优**的算法。

贪心算法并不能让我们得到每个问题的最优解，只能是大部分情况的最优解。

## 两者优劣势

显然动态规划准确率更高一些。

如果可以接受贪心带来的准确率下降，贪心有着更高的速度。

## 两者区别

从思路上来说，动态规划想要解决一个问题，必须先将问题最小化(简化为最小的原子，例如`n=1`),然后以这样的链路形式`n=1->n=2->...n=n`的解决方式，下一步解决方案依赖与上一步。

* 当`n=i`获得结果不是最优解，可以回退到上一步，继续尝试最优解法。
* **子问题划分是最明显的特点**

而 **贪心算法**，并不会从`n=1`开始解决问题。想要解决`n=j`的问题，就是会从`n=j`入手。

但是贪心算法最重要的要解决的问题是，当`n=j`的时候，**最理想的情况是那种？**

例如求解最少硬币(以中国硬币金额为例)，6可以由`[5, 1] or [2, 2, 2] or [1, 1, 1, 1, 1, 1]`

那么拿到最少硬币的问题直观的理想解法是：**尽量拿大面额的硬币，在大部分条件下是可以得到最优解**。对于上面这个问题的思路：

假设最大面额是`5`

1. 对于12来说，先优先拿`5`，可以拿到两个，超过两个就没有办法得到`12`
2. 然后现在最大面额是`2`，优先拿`2`

最后得到最优解，这就是贪心算法的解法。

区别在于：

* 贪心算法没有子问题
* 如果当前状态不是最优解，没有办法回退到上一步

**贪心算法比较动态规划更好理解！**
