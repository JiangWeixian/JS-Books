# 基础知识
> Cha 1th&Cha 2th&Cha 3th

## 静态语言类型和动态语言类型

`JavaScript`是动态语言类型。

### 鸭子类型

只要是它长得像，叫的像那么它就是鸭子。不用关心它到底是不是。

### 面向接口编程

> 例如,一个对象若有push和 pop方法,并且这些方法提供了正确的实现,它就可以被当作栈来使用。

## 多态

* 继承实现的多态，就像是动物可以是鸭子或者其他。这一点在静态类型中特别重要，因为不需要为一种特别的类型实现方法，只要实现其父类的方法就行了。

### JS - 基于原型的语言

* `clone`是这类语言实现继承的方式
* `JavaScript`的函数既可以作为普通函数被调用,也可以作为构造器被调用。当使用`new`运算符来调用函数时,此时的函数就是一个构造器。

## this&call&apply

* `this`在函数运行的时候指定。
* `apply&call` - 改变`this`的指向。

### bind

和`call`和`apply`区别在于，`bind`是返回一个函数，并不是立即执行。可以理解为`apply&bind`的柯里化实现。

## 闭包和变量声明周期

**首先**要知道JS只有函数生命周期而没有块的生命周期。

```javascript
for ( var i = 0, len = nodes.length; i < len; i++ ){
    nodes[ i ].onclick = function(){
    alert ( i );
  }
}
```

每次之后弹出5

在**你不知道JS**中的解释是，每次循环就只有一个变量`i`存在这个生命周期中。而`onclick`需要的是五个不同的变量。

`hack`方法就是对每个`onclick-function`绑定新的`i`到本身的生命周期上。非`ES6`的实现方案是：

```javascript
for ( var i = 0, len = nodes.length; i < len; i++ ){
    nodes[ i ].onclick = (function(){
    alert ( i );
  })(i)
}
```

这样`onclick`事件就有了存在其生命周期的变量`i`

### 实现一个闭包

* IIFE
* 或者就是函数内部返回一个函数

### 和内存关系

有一个观点就是闭包会造成内存消耗以及泄露，听起来很吓人

* 内存消耗的问题 - 如果讲这些变量放在闭包内部或者是全局中，都是一样的消耗
* 内存泄露的问题 - 
  > 如果闭包的作用域链中保存着一些DOM节点,这时候就有可能造成内存泄露;两个对象之间形成了循环引用存在内存泄漏

  但是以上问题都不是闭包引起的

JS内部有一个垃圾回收机制，就像名字那样会回收一些不使用的变量。

**我们可以使用这个方法来避免垃圾回收，把那些不使用的变量设置为null就行了**

### 节流&分时&预编译函数

* 节流函数 - 思想就是将一个函数延迟执行，在下一次需要再一次执行的时候。如果这个延迟函数存在，暂不执行。直到上一个延迟函数被执行完毕。

* 分时函数 - 例如当需要渲染一些列节点(**上千上百的时候**)。不再一次性渲染全部而是分阶段进行，每次渲染部分。直到全部完成。

* **预编译函数** - 在分析[柯里化](https://github.com/JiangWeixian/JS-Tips/blob/master/Grammar/JS-%E9%97%AD%E5%8C%85-%E6%9F%AF%E9%87%8C%E5%8C%96.md)的时候有提到这一点的优势。

