(window.webpackJsonp=window.webpackJsonp||[]).push([[73],{271:function(_,v,E){"use strict";E.r(v);var t=E(0),r=Object(t.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var _=this,v=_.$createElement,E=_._self._c||v;return E("div",{staticClass:"content"},[E("h1",{attrs:{id:"%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"}},[E("a",{staticClass:"header-anchor",attrs:{href:"#%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99","aria-hidden":"true"}},[_._v("#")]),_._v(" 设计原则")]),_._v(" "),E("blockquote",[E("p",[_._v("实践是最重要的")])]),_._v(" "),E("h2",{attrs:{id:"%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86---%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%8E%9F%E5%88%99"}},[E("a",{staticClass:"header-anchor",attrs:{href:"#%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86---%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%8E%9F%E5%88%99","aria-hidden":"true"}},[_._v("#")]),_._v(" 前置知识 - 设计模式和原则")]),_._v(" "),E("p",[_._v("设计原则并不是独立出来的。")]),_._v(" "),E("p",[_._v("一个模式也不是只有一种设计原则。")]),_._v(" "),E("p",[_._v("好的设计模式可能是多个设计原则的综合。")]),_._v(" "),E("h2",{attrs:{id:"%E5%8D%95%E4%B8%80%E5%8E%9F%E5%88%99srp"}},[E("a",{staticClass:"header-anchor",attrs:{href:"#%E5%8D%95%E4%B8%80%E5%8E%9F%E5%88%99srp","aria-hidden":"true"}},[_._v("#")]),_._v(" 单一原则(SRP)")]),_._v(" "),E("p",[_._v("一个对象方法只负责一件事情。")]),_._v(" "),E("ul",[E("li",[_._v("就像是添加图片节点和图片预加载和懒加载是两件事情。")]),_._v(" "),E("li",[_._v("构成对象和将对象封装为单例是两件事情，不需要在构建对象的时候，特意写成单例")])]),_._v(" "),E("p",[_._v("也就是能够封装的方法，就封装的优雅一些。是否封装的原则在于：")]),_._v(" "),E("p",[E("strong",[_._v("如果两个属性(或者方法对象)是同步的变化发生的话，就没有必要封装。")])]),_._v(" "),E("h3",{attrs:{id:"%E6%80%BB%E7%BB%93"}},[E("a",{staticClass:"header-anchor",attrs:{href:"#%E6%80%BB%E7%BB%93","aria-hidden":"true"}},[_._v("#")]),_._v(" 总结")]),_._v(" "),E("p",[_._v("其实这是两面性的概念，因为如果"),E("strong",[_._v("不封装，减少了扩展性，但是使用会优雅舒服一点。")])]),_._v(" "),E("h2",{attrs:{id:"%E6%9C%80%E5%B0%91%E7%9F%A5%E8%AF%86%E5%8E%9F%E5%88%99"}},[E("a",{staticClass:"header-anchor",attrs:{href:"#%E6%9C%80%E5%B0%91%E7%9F%A5%E8%AF%86%E5%8E%9F%E5%88%99","aria-hidden":"true"}},[_._v("#")]),_._v(" 最少知识原则")]),_._v(" "),E("p",[_._v("对象和对象之间减少耦合。")]),_._v(" "),E("p",[E("strong",[_._v("如何判断对象和对象之间是否耦合严重")]),_._v("，就是当一个对象变化的时候，另外的对象是否联动着变化。")]),_._v(" "),E("ul",[E("li",[_._v("为了体现这个原则，往往会引入第三方进行统一管理")]),_._v(" "),E("li",[_._v("在不那么复杂的情况下，也会使用闭包的原则("),E("strong",[_._v("函数变量")]),_._v(")")])]),_._v(" "),E("p",[_._v("这一点对我来说非常重要，因为是我比较难以把握的一点。")]),_._v(" "),E("h2",{attrs:{id:"%E5%BC%80%E5%8F%91%E5%B0%81%E9%97%AD%E5%8E%9F%E5%88%99"}},[E("a",{staticClass:"header-anchor",attrs:{href:"#%E5%BC%80%E5%8F%91%E5%B0%81%E9%97%AD%E5%8E%9F%E5%88%99","aria-hidden":"true"}},[_._v("#")]),_._v(" 开发封闭原则")]),_._v(" "),E("p",[_._v("不改变原有代码，只扩展原有代码。")]),_._v(" "),E("ul",[E("li",[_._v("装饰模式是很好的例子 - 不改变，只扩展")]),_._v(" "),E("li",[_._v("回调函数 - 不改变原有代码"),E("code",[_._v("API")]),_._v("，使用回调扩展")])]),_._v(" "),E("p",[_._v("进一步，分析"),E("strong",[_._v("不改变原有代码，只扩展原有代码")]),_._v("的理由是什么？")]),_._v(" "),E("ol",[E("li",[_._v("原有代码可能不满足要求，需要扩展功能")]),_._v(" "),E("li",[_._v("源代码维护扩展困难")])]),_._v(" "),E("p",[E("strong",[_._v("注意：源代码只是举例说明。有可能指的是某部分数据。")])]),_._v(" "),E("p",[_._v("也就是说"),E("strong",[_._v("源代码或者数据")]),_._v("处在变化状态，而我们需要这部分数据。依照开放-封闭原则：")]),_._v(" "),E("ol",[E("li",[_._v("代码变化 - 封装变化的这部分，不改变它，添加新的代码段成为一个新的函数。就像是"),E("strong",[_._v("装饰模式")]),_._v("那样(其他模式其实也体现了这个原则)。\n"),E("ul",[E("li",[_._v("例如"),E("strong",[_._v("代理模式")]),_._v("，封装对象方法，代理则起到了扩展作用。")])])]),_._v(" "),E("li",[_._v("数据变化 - 封装数据，监听数据变化。就像是"),E("strong",[_._v("发布订阅模式")])])]),_._v(" "),E("h2",{attrs:{id:"%E9%9D%A2%E5%90%91%E6%8E%A5%E5%8F%A3%E5%8E%9F%E5%88%99"}},[E("a",{staticClass:"header-anchor",attrs:{href:"#%E9%9D%A2%E5%90%91%E6%8E%A5%E5%8F%A3%E5%8E%9F%E5%88%99","aria-hidden":"true"}},[_._v("#")]),_._v(" 面向接口原则")]),_._v(" "),E("p",[_._v("API!是外部调用对象的方法。")]),_._v(" "),E("p",[_._v("在所有设计模式中都有体现，要实现某个具体功能，就要调用某个对象暴露在外面的方法("),E("code",[_._v("obj.fire()")]),_._v(")，这就是接口。")]),_._v(" "),E("h2",{attrs:{id:"%E4%BB%A3%E7%A0%81%E9%87%8D%E6%9E%84"}},[E("a",{staticClass:"header-anchor",attrs:{href:"#%E4%BB%A3%E7%A0%81%E9%87%8D%E6%9E%84","aria-hidden":"true"}},[_._v("#")]),_._v(" 代码重构")]),_._v(" "),E("p",[_._v("个人认为，这个概念包含很多。总有一些小细节可以在平时注意：")]),_._v(" "),E("ol",[E("li",[_._v("提炼代码为函数 - 为了更好的修改")]),_._v(" "),E("li",[_._v("重复代码段为函数 - 为了更好的复用，注意和第一点的区别")])]),_._v(" "),E("p",[_._v("只要代码写得多，这两点平时一定是非常注意的。还有一些我平时没有注意到的：")]),_._v(" "),E("ol",[E("li",[_._v("条件分支为代码 - 指的是("),E("code",[_._v("if (code)")]),_._v("指的是"),E("code",[_._v("code")]),_._v("那部分)")]),_._v(" "),E("li",[_._v("参数过多时候，用对象代替(类似"),E("code",[_._v("json")]),_._v("那种格式)")]),_._v(" "),E("li",[_._v("链式调用 - "),E("code",[_._v("promise")]),_._v("或者是"),E("code",[_._v("return this")]),_._v("都能够实现链式调用")]),_._v(" "),E("li",[_._v("分解大型类 - 如果一个类中有一个函数体量很大，推荐改进为类。")])])])}],!1,null,null,null);v.default=r.exports}}]);