(window.webpackJsonp=window.webpackJsonp||[]).push([[27],{239:function(t,e,r){"use strict";r.r(e);var i=r(0),s=Object(i.a)({},function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("div",{staticClass:"content"},[t._m(0),t._v(" "),t._m(1),t._v(" "),r("ul",[r("li",[t._v("编程可以用户友好可以性能优秀。性能就是基础，在性能优秀基础上得到更好的界面效果。")]),t._v(" "),r("li",[t._v("排序算法介绍")]),t._v(" "),r("li",[t._v("算法性能分析")]),t._v(" "),r("li",[t._v("简单介绍了大O计算方法(具体在第二课介绍)\n"),r("ul",[r("li",[t._v("不同复杂度算法性能比较")]),t._v(" "),r("li",[t._v("计算了插入排序的算法复杂度(和我在"),r("a",{attrs:{href:"https://github.com/JiangWeixian/JS-Books/blob/master/JS%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E9%83%A8%E5%88%86/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.md",target:"_blank",rel:"noopener noreferrer"}},[t._v("排序算法分析的一致"),r("OutboundLink")],1),t._v(")")]),t._v(" "),r("li",[t._v("计算了归并排序的算法复杂度")])])])]),t._v(" "),r("h2",{attrs:{id:"排序算法"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#排序算法","aria-hidden":"true"}},[t._v("#")]),t._v(" "),r("a",{attrs:{href:"https://github.com/JiangWeixian/JS-Books/blob/master/JS%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E9%83%A8%E5%88%86/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.md",target:"_blank",rel:"noopener noreferrer"}},[t._v("排序算法"),r("OutboundLink")],1)]),t._v(" "),r("p",[t._v("在标题链接文档中分析。")]),t._v(" "),r("ul",[r("li",[r("a",{attrs:{href:"https://github.com/JiangWeixian/JS-Books/blob/master/JS%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E9%83%A8%E5%88%86/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/insertSort.js",target:"_blank",rel:"noopener noreferrer"}},[t._v("插入排序"),r("OutboundLink")],1)]),t._v(" "),r("li",[r("a",{attrs:{href:"https://github.com/JiangWeixian/JS-Books/blob/master/JS%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E9%83%A8%E5%88%86/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/mergeSort.js",target:"_blank",rel:"noopener noreferrer"}},[t._v("归并排序"),r("OutboundLink")],1)])]),t._v(" "),t._m(2),t._v(" "),t._m(3),t._v(" "),t._m(4),t._v(" "),t._m(5),t._v(" "),t._m(6),t._v(" "),t._m(7),t._v(" "),t._m(8),t._v(" "),t._m(9),t._v(" "),t._m(10),t._v(" "),t._m(11),t._v(" "),t._m(12),t._v(" "),t._m(13),t._v(" "),r("p",[t._v("在数据量比较低的时候，高复杂度算法也可以表现良好。")]),t._v(" "),t._m(14),t._v(" "),t._m(15),t._v(" "),t._m(16),t._v(" "),t._m(17),t._v(" "),r("p",[t._v("利用递归树计算。")]),t._v(" "),t._m(18),t._v(" "),t._m(19),t._v(" "),r("p",[t._v("那么对于这个树来说：")]),t._v(" "),t._m(20),t._v(" "),t._m(21),t._v(" "),t._m(22)])},[function(){var t=this.$createElement,e=this._self._c||t;return e("h1",{attrs:{id:"课程介绍和算法分析"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#课程介绍和算法分析","aria-hidden":"true"}},[this._v("#")]),this._v(" 课程介绍和算法分析")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"简单速写"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#简单速写","aria-hidden":"true"}},[this._v("#")]),this._v(" 简单速写")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"性能分析"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#性能分析","aria-hidden":"true"}},[this._v("#")]),this._v(" 性能分析")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("算法分析要忽略硬件条件一些无关干扰，性能和"),e("strong",[this._v("以下几个方面")]),this._v("有关")])},function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("ul",[r("li",[t._v("输入情况 - 得到算法"),r("strong",[t._v("最差情况")])]),t._v(" "),r("li",[t._v("数据量 - 算法时间直接相关，因此要有"),r("strong",[t._v("算法的上限")]),t._v(" "),r("ul",[r("li",[t._v("讲数据量参数化转换为"),r("code",[t._v("n")]),t._v("，然后根据"),r("code",[t._v("n")]),t._v("来计算算法复杂度。也就是大O计数法")])])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("strong",[this._v("几个算法性能指标：")])])},function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("ul",[r("li",[r("code",[t._v("T(n)")]),t._v(" - 最大时间比较常用\n"),r("ol",[r("li",[t._v("算法运行最大时间，具体表达式，例如"),r("code",[t._v("n^2+n")]),t._v("之类的")]),t._v(" "),r("li",[t._v("平均时间，每种情况运行时间乘以情况出现概率")])])]),t._v(" "),r("li",[t._v("算法增加时间，对于一个"),r("code",[t._v("y = n^2 or y = n")]),t._v("算法，前面一种算法复杂度增加数值比后面一种高")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"大o计算法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#大o计算法","aria-hidden":"true"}},[this._v("#")]),this._v(" 大O计算法")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("计算的时候忽略低次项以及常数项目。例如"),e("code",[this._v("3n^3+2n^2")]),this._v("在大O表示出来就是"),e("code",[this._v("O(n^3)")]),this._v("。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("strong",[this._v("大O计算法原则1")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("当n趋向于无穷，"),e("code",[this._v("O(n^2)")]),this._v("永远比"),e("code",[this._v("O(n^3)")]),this._v("优秀。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("strong",[this._v("甚至在一个低性能计算机和一个高性能计算机也是成立的")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("strong",[this._v("大O计算法原则2")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("img",{attrs:{src:"https://raw.githubusercontent.com/JiangWeixian/JS-Books/master/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/Lesson01-%E8%AF%BE%E7%A8%8B%E4%BB%8B%E7%BB%8D%E5%92%8C%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/img/%E4%B8%8D%E5%90%8C%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83.png",alt:"不同复杂度性能分析"}})])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"具体计算"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#具体计算","aria-hidden":"true"}},[this._v("#")]),this._v(" 具体计算")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("strong",[this._v("插入排序-非递归计算")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("非递归算法 - 以插入排序为例子。递归计算为"),e("code",[this._v("1+2+...n=(1+n)*n/2")]),this._v("，根据大O表示法只保留算法的最高次幂，所以该算法就是一个"),e("img",{attrs:{src:"http://www.sciweavers.org/tex2img.php?eq=%20%5CTheta%20%28%20n%5E%7B2%7D%20%29&bc=White&fc=Black&im=jpg&fs=12&ff=arev&edit=0",alt:"img"}}),this._v("复杂度的算法。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("strong",[this._v("归并排序-递归计算(具体可看第二课)")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("img",{attrs:{src:"https://raw.githubusercontent.com/JiangWeixian/JS-Books/master/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/Lesson01-%E8%AF%BE%E7%A8%8B%E4%BB%8B%E7%BB%8D%E5%92%8C%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/img/%E9%80%92%E5%BD%92%E6%A0%91.png",alt:"递归树"}})])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("根节点假设是2的n次幂。假设是"),e("code",[this._v("8")]),this._v("，就是解决数据量为"),e("code",[this._v("8")]),this._v("的一个算法，递归树分析。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("ol",[e("li",[this._v("树高是"),e("code",[this._v("logn")])]),this._v(" "),e("li",[this._v("最下面一层的叶子节点为"),e("code",[this._v("n")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("因为对于递归来说，要转换为最小问题求解。所以最后一层是"),e("code",[this._v("O(1)")]),this._v("问题。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("那么算法复杂度就是"),e("code",[this._v("nlogn")])])}],!1,null,null,null);e.default=s.exports}}]);