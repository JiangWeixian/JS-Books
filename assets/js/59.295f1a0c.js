(window.webpackJsonp=window.webpackJsonp||[]).push([[59],{288:function(v,_,t){"use strict";t.r(_);var a=t(0),r=Object(a.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("div",{staticClass:"content"},[t("h1",{attrs:{id:"图"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#图","aria-hidden":"true"}},[v._v("#")]),v._v(" 图")]),v._v(" "),t("blockquote",[t("p",[v._v("grah")])]),v._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"#%E5%9B%BE"}},[v._v("图")]),v._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"#%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86---%E4%BB%80%E4%B9%88%E6%98%AF%E5%9B%BE"}},[v._v("前置知识 - 什么是图")])]),v._v(" "),t("li",[t("a",{attrs:{href:"#%E9%BB%98%E8%AE%A4%E5%9B%BE"}},[v._v("默认图")]),v._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"#%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0"}},[v._v("内置函数")])]),v._v(" "),t("li",[t("a",{attrs:{href:"#%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88"}},[v._v("广度优先")]),v._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"#%E9%BB%98%E8%AE%A4%E5%9B%BE---%E5%AF%BB%E6%89%BE%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84"}},[v._v("默认图 - 寻找最短路径")])])])]),v._v(" "),t("li",[t("a",{attrs:{href:"#%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88"}},[v._v("深度优先")]),v._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"#%E6%8B%93%E6%89%91%E7%BB%93%E6%9E%84"}},[v._v("拓扑结构")])])])])])])])])]),v._v(" "),t("h2",{attrs:{id:"前置知识-什么是图"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#前置知识-什么是图","aria-hidden":"true"}},[v._v("#")]),v._v(" 前置知识 - 什么是图")]),v._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/JiangWeixian/JS-Books/master/JS%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9B%BE/img/grah.png",alt:"grah"}})]),v._v(" "),t("p",[v._v("长得很像是树")]),v._v(" "),t("p",[v._v("额外：")]),v._v(" "),t("ol",[t("li",[v._v("连接线可以有方向")]),v._v(" "),t("li",[v._v("可以有权重")])]),v._v(" "),t("p",[t("strong",[v._v("图结构需要存储什么数据")])]),v._v(" "),t("ol",[t("li",[v._v("默认连接线是单向且没有权重的 - 需要保存节点和连接线(谁和谁连接了)")])]),v._v(" "),t("p",[t("strong",[v._v("图的方法")])]),v._v(" "),t("ol",[t("li",[v._v("遍历 - 深度和广度")])]),v._v(" "),t("ul",[t("li",[t("p",[v._v("广度(广度优先搜索算法会从指定的第一个顶点开始遍历图) - 和树结构不同地方在于，并没有左右子树概念。如果"),t("strong",[v._v("Map(数据结构Map)")]),v._v("，从顶点开始，然后先访问"),t("strong",[v._v("完毕")]),v._v("(也就是输出)连接点，然后再依次访问连接点的"),t("strong",[v._v("连接点")]),v._v("。")]),v._v(" "),t("p",[t("strong",[v._v("图如何确定顶点？")])]),v._v(" "),t("p",[v._v("个人认为应该是任意一个节点都可以是顶点。能确定顶点的都是有方向的图，没有方向(或者说是双向的)个人理解任意一点都可以。")])]),v._v(" "),t("li",[t("p",[v._v("深度优先，从顶点开始"),t("code",[v._v("A")]),v._v("，先访问其连接点"),t("code",[v._v("B")]),v._v("("),t("strong",[v._v("并不会全部访问")]),v._v("完所有连接点)，而是继续访问连接点"),t("code",[v._v("E")]),v._v("(所以叫深度)，可以发现从"),t("code",[v._v("B")]),v._v("点开始的那个步骤很像就是"),t("code",[v._v("A")]),v._v("点步骤的重复。"),t("strong",[v._v("深度比广度更适合递归。")])])])]),v._v(" "),t("p",[t("strong",[v._v("两种方式存储数据")])]),v._v(" "),t("ol",[t("li",[v._v("数组 - 如果图中6个节点就是6*6的数组，如果有连接数值对应位置设置为1。如果没有就设置为0")]),v._v(" "),t("li",[v._v("Map(数据结构Map) - "),t("code",[v._v("key")]),v._v("是节点，"),t("code",[v._v("value")]),v._v("是和"),t("code",[v._v("key")]),v._v("相连的节点")])]),v._v(" "),t("h2",{attrs:{id:"默认图"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#默认图","aria-hidden":"true"}},[v._v("#")]),v._v(" 默认图")]),v._v(" "),t("ul",[t("li",[t("p",[v._v("连接单向以及"),t("strong",[v._v("权重为1")])])]),v._v(" "),t("li",[t("p",[v._v("含有两个内置属性，分别是"),t("code",[v._v("vertex")]),v._v("以及"),t("code",[v._v("adlist")]),v._v("，分别存储节点和边。")]),v._v(" "),t("div",{staticClass:"language-JavaScript extra-class"},[t("pre",{pre:!0,attrs:{class:"language-javascript"}},[t("code",[v._v("vertices "),t("span",{pre:!0,attrs:{class:"token operator"}},[v._v("=")]),v._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("[")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("]")]),v._v("\nadjList "),t("span",{pre:!0,attrs:{class:"token operator"}},[v._v("=")]),v._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("new")]),v._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[v._v("Dictionary")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(")")]),v._v("\n")])])])])]),v._v(" "),t("h3",{attrs:{id:"内置函数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#内置函数","aria-hidden":"true"}},[v._v("#")]),v._v(" 内置函数")]),v._v(" "),t("ul",[t("li",[v._v("addVertex - 添加节点")]),v._v(" "),t("li",[v._v("addEdge - 在已经有的节点基础上，添加和那些边相互连接")]),v._v(" "),t("li",[v._v("广度优先")]),v._v(" "),t("li",[v._v("深度优先")])]),v._v(" "),t("h3",{attrs:{id:"广度优先"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#广度优先","aria-hidden":"true"}},[v._v("#")]),v._v(" 广度优先")]),v._v(" "),t("ul",[t("li",[v._v("定义一个状态机，分别是节点未访问(默认状态)，访问(和它相互连接的节点还没有"),t("strong",[v._v("完全访问完毕")]),v._v(")，探索完毕(节点被访问以及下面的节点也完全被访问完毕)\n"),t("ul",[t("li",[v._v("white - 未访问")]),v._v(" "),t("li",[v._v("grey - 访问")]),v._v(" "),t("li",[v._v("black - 探索完毕")])])]),v._v(" "),t("li",[v._v("定义一个队列("),t("strong",[v._v("广度优先特有的，在树结构的广度中也是如此")]),v._v(")，记录"),t("strong",[v._v("访问状态")]),v._v("的节点，如果是"),t("strong",[v._v("探索完毕")]),v._v("就不要添加了。")])]),v._v(" "),t("p",[t("strong",[v._v("开始广度优先")])]),v._v(" "),t("p",[v._v("添加起始节点到队列")]),v._v(" "),t("ol",[t("li",[t("strong",[v._v("弹出")]),v._v("队列第一个节点，从给定节点开始访问")]),v._v(" "),t("li",[v._v("访问下面连接节点，如果下面连接节点在对应状态机里面是"),t("code",[v._v("gray(访问)状态")]),v._v("，就"),t("strong",[v._v("添加")]),v._v("到队列中")]),v._v(" "),t("li",[v._v("节点探索完毕，回到第一步")]),v._v(" "),t("li",[v._v("直到队列为空")])]),v._v(" "),t("h4",{attrs:{id:"默认图-寻找最短路径"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#默认图-寻找最短路径","aria-hidden":"true"}},[v._v("#")]),v._v(" 默认图 - 寻找最短路径")]),v._v(" "),t("p",[v._v("实现"),t("strong",[v._v("某一个定点到任意定点")]),v._v("的最短路径。")]),v._v(" "),t("p",[v._v("由于权重为1(也就是连接线没有长短之分)，所以直接最短路径和连接线数目有关。")]),v._v(" "),t("ul",[t("li",[v._v("记录路径长度 - "),t("code",[v._v("d")])]),v._v(" "),t("li",[v._v("记录该点的上一点(如果该点第一次被访问呢) - "),t("code",[v._v("p")])])]),v._v(" "),t("p",[t("strong",[v._v("开始寻找最短路径(广度优先算法流程)")])]),v._v(" "),t("ol",[t("li",[t("strong",[v._v("弹出")]),v._v("队列第一个节点，从给定节点开始访问")]),v._v(" "),t("li",[v._v("访问下面连接节点，如果下面连接节点在对应状态机里面是"),t("code",[v._v("gray(访问)状态")]),v._v("，就"),t("strong",[v._v("添加")]),v._v("到队列中。设置"),t("code",[v._v("p")]),v._v("中该点上一个节点(保证下一次访问同一个节点不会加入"),t("code",[v._v("p")]),v._v(")；设置"),t("code",[v._v("d")]),v._v("中该点路径为"),t("strong",[v._v("上一个节点路径+1")]),v._v("(因为达到该点需要经过上一个节点，所以该点路径是上一个点路径+1)")])]),v._v(" "),t("blockquote",[t("p",[v._v("如果下面连接节点在对应状态机里面是"),t("code",[v._v("gray(访问)状态")]),v._v("才会被加入"),t("code",[v._v("d&p")]),v._v("。保证某点上一个点只有唯一一种可能；"),t("strong",[v._v("因为对最短路径寻找来说，第一次访问最短，第二次访问一定是经过了中间节点。")])])]),v._v(" "),t("ol",{attrs:{start:"3"}},[t("li",[v._v("节点探索完毕，回到第一步")]),v._v(" "),t("li",[v._v("直到队列为空")])]),v._v(" "),t("p",[t("strong",[v._v("还需要经过第二步骤")])]),v._v(" "),t("p",[v._v("假设我们得到的"),t("code",[v._v("p")]),v._v("是"),t("code",[v._v('predecessors: [A: null, B: "A", C: "A", D: "A", E: "B", F: "B", G: "C", H: "D", I: "E"]')])]),v._v(" "),t("p",[v._v("大致解释一下：")]),v._v(" "),t("ul",[t("li",[v._v("A是起点，所以上一个节点是"),t("code",[v._v("null")])]),v._v(" "),t("li",[v._v("假设"),t("code",[v._v("E")]),v._v("是终点，"),t("code",[v._v("E")]),v._v("上一个点"),t("code",[v._v("B")]),v._v("，"),t("code",[v._v("B")]),v._v("上一个点"),t("code",[v._v("A")]),v._v("。所以"),t("strong",[v._v("A到E")]),v._v("就是"),t("strong",[v._v("A->B->E")])])]),v._v(" "),t("p",[t("strong",[v._v("根据"),t("code",[v._v("p")]),v._v("绘制出路径图")])]),v._v(" "),t("p",[v._v("以A为起点，寻找终点"),t("code",[v._v("X")]),v._v("。")]),v._v(" "),t("ol",[t("li",[v._v("如果"),t("code",[v._v("X")]),v._v("上一个节点是"),t("code",[v._v("A")]),v._v("那么终止")]),v._v(" "),t("li",[v._v("如果不是，找到"),t("code",[v._v("X")]),v._v("的上一个节点，直到上一个节点是"),t("code",[v._v("A")])])]),v._v(" "),t("h3",{attrs:{id:"深度优先"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#深度优先","aria-hidden":"true"}},[v._v("#")]),v._v(" 深度优先")]),v._v(" "),t("p",[v._v("适合递归实现。")]),v._v(" "),t("ol",[t("li",[v._v("从某一点"),t("code",[v._v("v")]),v._v("开始("),t("strong",[v._v("未被探索的")]),v._v(") - 访问未被探索是关键所在")]),v._v(" "),t("li",[v._v("访问某一点的连接点"),t("code",[v._v("w")])])]),v._v(" "),t("ul",[t("li",[v._v("然后访问连接点的连接点"),t("code",[v._v("x")]),v._v("(第一个) - 对于"),t("code",[v._v("x")]),v._v("是从第1步开始重复，直到最后一层。然后回到上一步，从第2个节点继续重复。")])]),v._v(" "),t("ol",{attrs:{start:"3"}},[t("li",[v._v("当某一个节点的子链接点都访问完全之后，才会标记为"),t("strong",[v._v("被探索")])])]),v._v(" "),t("p",[t("strong",[v._v("看图更为明确一些：")])]),v._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/JiangWeixian/JS-Books/master/JS%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9B%BE/img/dfs.png",alt:"dfs"}})]),v._v(" "),t("h4",{attrs:{id:"拓扑结构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#拓扑结构","aria-hidden":"true"}},[v._v("#")]),v._v(" 拓扑结构")]),v._v(" "),t("p",[t("strong",[v._v("拓扑结构如图所示：")])]),v._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/JiangWeixian/JS-Books/master/JS%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9B%BE/img/%E6%8B%93%E6%89%91%E7%BB%93%E6%9E%84.png",alt:"拓扑结构"}})]),v._v(" "),t("ul",[t("li",[t("strong",[v._v("被访问")]),v._v("会被标记为上先后顺序的数字，左边")]),v._v(" "),t("li",[t("strong",[v._v("探索完毕")]),v._v("之后标记上探索完毕的记号，代表先后顺序，右边")])]),v._v(" "),t("p",[v._v("可以代表任务先后顺序")]),v._v(" "),t("p",[v._v("被访问先后顺序很好理解，探索完毕先后顺序是由于这是"),t("strong",[v._v("所有子节点都被访问完毕的状态")]),v._v("。所以最外层的节点是最后被退出的。")])])}],!1,null,null,null);_.default=r.exports}}]);